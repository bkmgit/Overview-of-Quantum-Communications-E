\chapter{BB84: Single-photon QKD}


\section{Three phases of cryptographically secure communication}

Hi, and welcome to Lesson Nine.

This lesson will be on a single-photon QKD, and particularly on the first single-photon QKD protocol known as BB84.

So, Step One: what are the "Three Phases of Cryptographic Secure Communication"?

So secure communication proceeds roughly in the following three phases: first, the parties need to authenticate each other, meaning that they identify to each other that they are really the parties that they want to communicate with and not somebody else. Then, they have to generate a key that they will use for encoding their message. After the key is generated, they can get into encoding their message and encrypt their data, send it to the other party where it will be decrypted. So, authentication between Alice and Bob usually proceeds in the following way (see slides): So first, Alice says that "I'm Alice" to Bob. Then Bob can say, "Okay, you're Alice, I'm Bob". Then also, anybody could say that, so the question is: why should I believe you? Why should I trust you? Why are you really the person that you're claiming to be? And Bob, of course, has the same question.

So generally, the message, and the procedure, how two parties can authenticate each other is who are you, what do you have, and what do you know, and in particular the last one is quite important, because you know that the party that you are trying to communicate knows something, for example like a public key or a pre-shared search secret, and that can be used as an authentication device. So after authentication, they have to generate a "key". Now the key will be subsequently used for encrypting the message, and the key- for example there are many different ways of exchanging keys, such as Diffie-Hellman key exchange is one such method, but the problem with the key is that once it is generated, it can be used but it cannot be used forever. It always has to be changed and it has to be changed frequently in order to ensure that the data is encrypted in a secure manner.

So, once the key is generated, Alice can encrypt her message with the key. She can send it to Bob, where Bob will use his generated his part of the generated key to decrypt the message and read it.

And common forms are are the following: DES, 3-DES, AES. Less common one is one-time pad (OTP) and we will describe what one-time pad is, sometimes it's known as the Vernam cipher.


\section{Private vs public key}

Step Two: Private versus Public Keys

So one way to establish a private key between Alice and Bob is to use public channel, and keys that are established in such a way are known as public keys. So here's how it works.

We've got two parties that are trying to communicate, Alice and Bob, and they can communicate over a public channel. "Public" means that anybody has access to this channel, so any message that they transmit that they used to communicate with can be heard and intercepted by any other party. So this channel is not secure, in the sense that anybody can read any message that they sent. So what Alice does is she generates two keys: one is known as the "public key" and the other one is known as the "private key". What she then does is she sends the public key to Bob that she generated, he uses that to encrypt his message, and then what he does is he can just send it back to Alice. Then she uses the private key that she did not communicate to Bob to decrypt Bob's message and read what it is. So in public key cryptography, public key is used to encrypt the message but it cannot be used to decrypt the message. The message is decrypted by the private key that Alice generated but did not share with over the public channel.

And it works, but it has some disadvantages. It is slow, it is expensive, and more importantly it is what's known as computationally secure, meaning that anybody listening to the channel is able, in principle, to break the encryption if, either they have a large amount of computational resources or computational time. So it is not unconditionally secure.

A different way of establishing and, this is the crucial point, is that quantum computers can in principle break computationally secure protocols like this with relative ease. So, how can we actually establish secure connection between Alice and Bob? The other alternative method is to use a "private key". Here, what happens is that there is some generator, some hypothetical device, that can generate private key, and that key is then sent to Alice and sent to Bob. Now, Alice and Bob are sharing some correlated secret key that only they know, and they can use it to encrypt their message. For example, Bob encrypts his message, he sends it to Alice where Alice uses her part of the secret key to decrypt it and read the message. This is known as "one time pad" or the Vernam cipher, and it is secure it cannot be broken provided that is used only once. So, if Bob has a message of n bits that he's trying to send to Alice, he requires a private key that's at least n bits long, and once he uses that private key to encrypt his message he cannot use it again. If he has some other thing to say to Alice, they require a completely new and fresh private key to ensure security.

So, as we said, it's not very efficient in the sense that it requires large amount of key bits. The number of keys has to be at least as high- as big as the message itself.

So, that's actually pretty good, but there is one remaining question, and that's how do we actually distribute this key? In this scenario, we just assume that the private key generator can distribute this private key to Alice and Bob, but of course there is a question of what channel should the private key generator use? Because public channels are monitored by whoever is listening, and this is where quantum mechanics comes into play, as we will see in the next step.



\section{BB84 Protocol}

Step Three: BB84 Protocol

This protocol is a quantum protocol, therefore Alice and Bob can utilize a public quantum channel, as well as their public classical channel.

So here (on slide) we've got Alice and Bob again, and they can communicate over this public quantum channel. What Alice does to begin the protocol, is she generates two n-bit strings. We're going to call the first n-bit string "a", so there's n bits in her string a, we're going to denote them a1, a2, up to a-n, and the second bit string we're going to denote is "b", and there's b1, b2, all the way up to b-n.

And then what she does is she creates quantum states according to these bit strings as follows:

For each two bits from a and b, she takes them and creates one qubit, and then she creates n such qubits and the whole state will be denoted by psi. So, if her qubits a-k and b-k are (in state) (zero zero), then she encodes this qubit, she prepares the qubit in the state zero. If a-k and b-k are (one zero), then she prepares state one. Similarly, if they are (zero one), she prepares state plus, and if they are (one one), she prepares the state minus. So, we can see that the bit coming from the bit string b, determines the basis of Alice's encoding. If it's zero, as we can see in both of these cases here and here (see pointer), she prepares the qubit in the z basis. If it's one, as we see in this case and in this case (psi 01, 11), then she prepares the qubits in the x basis. And a-k then chooses which state from the basis she prepares. If a is zero, she prepares the plus one eigenstate, if it's one, she prepares the minus one eigenstate.

Notice that these states are not orthogonal. For example, if we take the inner product between psi zero zero and psi zero one, like here, we see that they are not orthogonal, meaning that their inner product is non-zero. In this particular case, it's one over square root of two. Same if we take, for example, the state psi one zero and psi one one, again we will get that the inner product is non-zero. When this happens, when the inner product is non-zero, it means that the two states are not perfectly distinguishable, and this is crucial ingredient in this protocol. So what does it mean for two states to be non distinguishable? Let's consider the case where we are measuring in the z basis, and we are given two states. One state is the "zero state", and the other state is the "one state". If this happens, we see that they are orthogonal, it means we can perfectly distinguish them. So if we just keep measuring the incoming qubits, if the qubit is in zero, we will always get a plus one outcome. On the other hand, if the qubit is in one, we will always get minus one outcome. So with certainty, we can distinguish whether the incoming qubit is a zero or a one.

Same thing applies if we are measuring in the x basis, and we are given only state plus or state minus, like here (follow pointer). If we keep measuring x and we get this state, then the outcome will be always plus one with hundred percent probability. If on the other hand we get a minus state, and we measured in the x (basis), we will get outcome minus one all the time. So in this sense, we can distinguish plus and minus if we're measuring in the x basis.

On the other hand, let's say that we are given this following states- zero or a plus, and we measure in the z basis. So if we measure the zero state like we said we always get the plus one outcome, that's fine. But if we measure the second state, the plus state, there's a fifty percent probability that we get the outcome plus one and fifty percent probability that we get the outcome minus one.

So, if we get a state zero, all is good, but if we get the state plus, sometimes we will get a plus one and sometimes we will get a minus one. If we get the minus one state, fine, we can say we know that this state is plus, but if we get the plus one outcome, we are unsure whether the state is a plus or whether it's a zero. In this sense, the states are non-distinguishable. We can do the same thing in the x basis, and here the scenario is reversed. With certainty, we can say that we get plus one outcome here (yellow box RHS), but if we measure in the x basis and we receive the state zero, sometimes it will be a plus one and sometimes a minus one.

So let's consider an example of the encoding. Let's say that Alice generates "string a", which is (zero one one zero one), and "string b" (one one zero zero one). So then, she starts encoding, she looks at the first bit in her string b, which is one, so she knows, "now I have to encode in the x basis", and the state that she prepares is a plus state because her first bit in the a-string is a zero. So, that's her first qubit that she prepares. The second qubit, she looks at the second bit in her string-b, which is again one, so again she knows she has to prepare a state from the x basis, and the state is given by this second bit in string-a, which is one, therefore she prepares the state minus, and then she goes on and on until she prepares all n-qubits.

What she does then is she sends these qubits to Bob over the public quantum channel. Now, let's consider what Bob knows at this time. He actually doesn't know what these states are, because Alice did not share the secret string-b containing information about the preparation basis with anybody, she kept it secret. Therefore, all Bob knows is that he's receiving qubits and they can be any of the four possible states: zero, one, plus, minus. But, what he does, he goes on anyway and he creates his own random bit string which we are going to denote as b-prime. And again, because he's expecting n-qubits, he generates n-bits: b1 prime, b2 prime, all the way until b-n prime. And what he then does, he just measures in the basis given by this bit string.

So, similarly to Alice, if the bit "b-prime k" is zero, then he measures in the z basis, and if it's in one then he measures in the x basis. This allows him to generate his own random bit string which we will denote "a-prime". So if the outcome of the k-th measurement on the qubits is plus one, then he will assign zero to bit "a-prime k", if it's minus one, then he assigns a bit one to "a-prime k", and this way he generates his own "a-prime" random bit string. What then happens is that Alice and Bob, they share information with each other over a public classical channel. Alice shares her randomly generated bit string n, and Bob shares his randomly generated bit string b-prime.

So, they exchange information about the basis in which the qubits were prepared and in which they were measured.

And what they do is, if they measured and prepared in the same basis, they will keep the corresponding bits from "a" and "a-prime". If they measured in different bases, then they just discard the bits "a-k" and "a-prime k". Why? Because as we said, if Alice prepares in a certain basis and Bob measures in that basis, the two possible states are orthogonal, meaning they are perfectly distinguishable by measurement in that basis, so it allows Bob and Alice to generate a perfectly correlated key. So the bits that they keep, we're going to denote as "a-bar" and "a-bar prime", and they are perfectly correlated, meaning that these two shorter bit strings that they generated are in fact, equal. And now, they are sharing a key that they can use in the next step, which is encryption of the data.

So for example, how does it work? Let's again consider case where n is equal to five. So Alice has randomly generated five bit strings, a and b. "b" tells her in which basis she should encode, "a" tells her what the state should be. So she prepares the following states: (minus zero plus minus one). Bob generates his own random b-string, "b-prime". Again, this bit string is different from Alice's "b" because he doesn't know Alice's "b" at this time, and he just measured in the basis given by b-prime, so here the first bit in b-prime is one. Therefore, he measures in x on the second bit. It's again one, therefore he measures in x, and so on and so forth. And you can see that since for the first qubit, Alice encoded the qubit in basis x, and Bob measured in basis x, therefore Bob will always, with hundred percent probability, get the outcome minus one, which we said corresponds to bit string a-prime which is equal to one. And we see that in this case, "a-prime one" is the same as Alice's "a one". On the other hand, for the second qubit, Alice prepared the qubit in the z basis. But because Bob's random bit "b-prime two" is given by one, he measured in the x basis. So with fifty percent probability he can obtain zero, with fifty percent probability he can obtain one. So they cannot be sure that they are really sharing a correlated bit, therefore they discard this bit (second bit/row). For the third qubit, again Alice prepared in the same basis as Bob measured, therefore they know in this place, they can keep this bit and use it as part of their secret key. And this way, they can generate shorter keys but which are one hundred percent correlated. So here (see slide), we see for the first bit, they keep it, second one they discard, third one they keep it, fourth one they discard, and the last one they also keep.

So, the shared key that they have is given by: (one zero one).

So, here's the summary of the protocol so far: Alice starts by generating two n-bit strings, a and b. "b" is used for basis of the preparation, whereas "a" tells which state of that particular basis Alice should prepare the qubit in. If b-k is equal to zero, then she prepares in the z basis, if b-k is equal to one, she prepares in the x basis. Then, Alice sends these qubits to Bob over a public quantum channel. Bob measures randomly either in z or x basis. After the measurements are completed, and only after that, they are allowed to share the information about the preparation basis and the measurement basis, and they keep the bits only where they prepared and measured in the same basis. Again, they do that because they are guaranteed that in this scenario, the results that are generated are hundred percent correlated. And whatever is left of the key, they use as a secret key for encoding and decoding their messages.

Now, so far, we have only considered the ideal scenario where there was no eavesdropper. Now let's say that somebody is listening to both the public classical channel, but also the public quantum channel. So we are going to consider the effect of an eavesdropper whom we are going to name Eve, and see what effect that has on the protocol and how the protocol can actually discover the presence of such an eavesdropper.



\section{Eavesdropper detection}

Step Four: Eavesdropper Detection

In the previous step, we have seen how the ideal protocol works. Now let's see what happens when we include the effect of an eavesdropper trying to gain access to the secret key that Alice and Bob are trying to generate.

So we've got the following scenario: we've got our Alice communicating over a public quantum channel with Bob, and there is some third party Eve, that wants to intercept their messages.

So, what can Eve do? Let's assume that she can take these qubits (follow pointer) that Alice is sending over the public quantum channel to Bob. She intercepts them, she can copy them and then resend them to Bob. That would give her access to the protocol and the qubits, and also subsequently the secret quantum key. Luckily, she cannot do that due to the "no cloning theorem" as we have seen in the previous lesson, in the teleportation lesson. So, she cannot simply take them, make a copy of the qubit, and then resend the qubits to Bob. That's good. So in order for Eve to gain any access to the information that Alice is trying to share with Bob, she has to measure these qubits. So, what can happen then? She has to guess the basis of measurement, because remember, the preparation basis stored in the bit string "b", is still kept a secret by Alice, that has not been communicated over a public classical channel to Bob. Therefore, Eve does not have access to this information. So, in order to measure these qubits, she just has to pick a random basis. But, she knows that the two choices for the basis is either z or x.

So, if she measures in some basis, this has a chance to disturb the qubit.

For example, if Alice prepares the qubit in the x basis, and Eve measures in the x basis, then we have seen that in such a scenario, there is no disturbance. The qubit is still projected onto the same state that it was prepared in, so it doesn't change the state of the qubit and it doesn't change the basis of the qubit. However, in the second case, let's say that Alice's preparation basis is "z", and Eve's measurement basis in is x, so the qubit originally prepared by Alice was either in a zero state or a one state. These are just two possible states in the z basis. But by measuring them in the x basis, Alice is now projecting onto the either plus state or a minus state. So, she disturbed both bases and the state. Similarly in this scenario here (follow pointer), where Alice prepares in the x basis and Eve measures in the z-basis. And this is the main principle how Eve will be detected by Alice and Bob.

So, if she guesses wrong, if Eve guesses wrong, she will change the basis of the qubit.

So let's see what happens. Alice prepares her qubits, she starts sending them over the public quantum channel, Eve intercepts these qubits and she measures them in a random basis, and then she passes on these qubits to Bob. So, some of these qubits where she guesses correctly, so she measures in the preparation basis, they do not get disturbed. But some of these qubits, represented by these black qubits (see slide), they become disturbed. This is when Alice measures in a different basis than the preparation basis. Then, this gives Alice and Bob an opportunity to detect that there is an eavesdropper present. How does that happen?

Basically, what they need to do is they go through with their BB84 protocol. They compare their bases in which Alice prepared and both measured. They keep only those bits where they measure the qubits in the same basis, and then they dedicate a portion of this new shorter key to finding to detecting an eavesdropper Eve. So Eve has a chance of measuring in the same basis as the preparation basis of one half, so fifty percent. And also Bob chooses the same basis as Alice with probability fifty percent. So this gives Alice and Bob a probability of one quarter to detect an existence of Eve, because remember, if Alice prepared in one basis and Bob measured in the same basis, they are expecting this classical measurement outcomes to be the same- they are expecting to share a perfectly correlated key. But if Eve measured this qubit and disturbed this qubit, then there is a chance that these two bits will not coincide, and if they don't coincide then Bob and Alice know that something went wrong and there's an eavesdropper present trying to gain access to their secret key.

So, we said that "Eve" (the eavesdropper) can be detected with probability one quarter when it comes to measuring a single qubit. When there's n qubits that she measures, the overall probability of detecting "Eve" is given by the following expression: one minus three quarter to the power of n. So let's see how this scales with the number of n.

Here it is (see slide): on the horizontal axis, we're plotting the length of the bit string that we dedicated to detecting an eavesdropper Eve, and on the vertical axis, we've got the probability of detecting Eve. So you see, as the number is very small, so "small n" is very small, we don't dedicate too many bits to actually trying to detect the eavesdropper, then also the probability that Eve is detected is relatively small. But very quickly, this probability shoots very close to one. So with nearly a probability of hundred percent, Alice and "Bob" can detect the presence of an eavesdropper. Even for n equals to 25 (twenty five), so if they dedicate 25 bits to detect Eve, the chance is one in a thousand that Eve will not be detected. So it's very very small, meaning with very high probability, Alice and Bob know that somebody's eavesdropping onto their channel, so they can just say, "we know that we are not sharing a secure secret key, therefore we choose not to continue with the rest of our communication, and we don't allow Eve to gain access to our sensitive message".



\section{Existing QKD network testbeds}

Step Five: Existing QKD Network Testbeds

In the previous steps, we have seen how Alice and Bob can use quantum mechanics to discover an eavesdropper and generate a secret random key for secret communication. In this step, we will demonstrate that actually these things are not only in the realm of theoretical research, but also have been tested by building real networks.

So the very first network that was built was known as the DARPA QKD network, all the way back in 2004. And this included ten nodes in a network, and it was built in the state of Massachusetts in the USA. And in particular, it included different physical links, for example here (see pointer), you had a communication over free space, here you had a communication over a fiber. So this was unlike any of the previous experimental implementations where secure quantum communication in the form of a single photon-based QKD was done only on a point-to-point basis over a single link. This was the first network experiment demonstrating the viability of quantum key distribution.

The next experimental effort was in Europe known as the SECOQC QKD network. SECOQC stands for "Secure Communication based on Quantum Cryptography", and it was around the year 2008. It launched in Vienna, and it comprised of six nodes and eight links, and involved the layered architecture. And finally, there are many other experiments but one notable one was done in Tokyo around 2010, and it was known as the Tokyo QKD network. Here (follow pointer), you can see the physical map actually, which places in Tokyo were connected. You have Hongo campus here in Tokyo University, you've got Otemachi over there, and it reached all the way to NICT in Kogane, and the interesting part about this network that actually it was used for a quantum secure video conference which really demonstrated the viability of using quantum mechanics for securing communication in a network.


\newpage
\begin{exercises}
\exer{Consider the following quantum state:}
\begin{equation*}
\ket{\psi} = \frac{\sqrt{3}}{2}\ket{0} + \frac{1}{2}\ket{1}
\end{equation*}
\subexer{Find the probability of measuring a zero.}
\subexer{Find the probability of measuring a one.}


\end{exercises}

