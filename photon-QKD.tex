\chapter{BB84: Single-photon QKD}

This chapter introduces single-photon QKD, and particularly the first single-photon QKD protocol known as BB84.

\section{Three phases of cryptographically secure communication}

% So, Step One: what are the "Three Phases of Cryptographic Secure Communication"?

Secure communication using encryption proceeds roughly in the following three phases: first, the parties need to authenticate each other, meaning that they prove they really are who they say they are and not somebody else. Second, they have to select or generate a key that they will use for encoding their messages.  Third, after the key is generated, they can encode their messages and encrypt their data, then send them to the other party where they will be decrypted -- the actual bulk data transfer phase of the conversation.

Authentication between Alice and Bob usually proceeds in the following way: first, Alice says, "I'm Alice," to Bob. Then Bob can say, "Okay, you're Alice, I'm Bob". But of course, anybody could send that reply, so Alice's question is: "Why should I believe you? Why should I trust that you are really the person that you're claiming to be?" And Bob, of course, has the same questions.

Generally, the procedure two parties use to authenticate each other depends on one of three things: something you \emph{are}, something you \emph{have}, or something you \emph{know}. (This applies as well in the real world; trying to get into a private club or 1920s U.S. speakeasy might involve personal recognition, a physical token such as an actual key, or a password you have been given by someone else.)  In particular the last one is quite important, because you know that the party that you are trying to communicate knows something, for example a secret pre-shared between the two parties, or generally and flexibly the private key corresponding to a particular public key, and that can be used as an authentication device.

After authentication, Alice and Bob have to generate a \emph{cryptographic key} (or just "key"). There are many different ways to exchange keys, such as Diffie-Hellman key exchange, which we don't need to go into here. The key will be subsequently used for encrypting the message, but the problem with the key is that once it is generated, it cannot be used forever. It has to be changed at regular intervals in order to ensure that the encrypted data remains secure.

Once the key is generated, Alice encrypts her message with the key. She sends it to Bob, where he will use his share of the generated key to decrypt the message and read it.  Typically, this \emph{bulk data encryption} phase of the conversation is a \emph{symmetric key cryptosystem}, where Alice and Bob use the same key to encrypt and decrypt the messages. Common forms include the now-outdated Data Encryption Standard (DES), the stronger (and still in use) 3-DES, and the modern Advanced Encryption Standard (AES). Less common one is one-time pad (OTP)\index{one-time pad (OTP)}. Later we will describe the one-time pad, which is also known as the \emph{Vernam cipher}\index{Vernam cipher}.

Quantum key distribution, or QKD, is used in the second phase of this process.  Before we go into QKD, let's look briefly at how keys are established today when you use the Internet.

\section{Private vs. public key}

We have two parties, Alice and Bob, that are trying to communicate, and they can communicate over a public channel. "Public" means that anybody has access to this channel, so any message that they transmit can be heard and intercepted by any other party. So this channel is not secure, in the sense that anybody can read any message that Alice and Bob send. And yet, somehow Alice and Bob need to authenticate each other and prepare the key to be used for the bulk data encryption.

The simplest method is via a \emph{pre-shared key}. Alice and Bob meet somewhere, face to face, long before they want to communicate.  At this meeting, they create a shared secret between them, known to no one else.  This key can then be used later to authenticate each other, and to help generate the keys used for the bulk encryption.  Of course, for this method to work as a general mechanism for any two parties, every person must meet every other person.  That requires $O(N^2)$ meetings for $N$ people, which is obviously not practical.

To compensate for this shortcoming, instead we use mechanisms that don't require this prior agreement. One method is known as \emph{public key cryptography}\index{public key cryptography}. Alice generates two keys: one is known as the "public key" and the other one is known as the "private key".  In public key cryptography, the public key is used to encrypt the message but it cannot be used to decrypt the message. 
The private key is needed to decrypt the message.  For this reason, public key cryptography is sometimes called \emph{asymmetric} cryptography.  Bob's public key is published in some fashion that allows Alice both to find Bob's key when she needs it, and trusts that it is really Bob's key.  Alice uses that to encrypt her message, and then sends it to Bob. Bob then uses the private key (which he has kept secret) to decrypt Alice's message and read it.  The most prominent form of public key cryptography is known as RSA.

This process works, but it has some disadvantages. It is slow and expensive. While it is theoretically possible for Alice to encrypt her actual message to Bob using public-key cryptography, which would combine the functions of authentication and encryption while eliminating the need for a separate key, it is not practical.  Therefore, we usually use three separate functions as described in the last section, with RSA for authentication, Diffie-Hellman for session key generation, and AES for bulk data encryption.

More important than the performance issues with public key cryptography, the security of both RSA and Diffie-Hellman is based on the idea that they are \emph{computationally secure}.  Of course, anybody listening to the channel is able to record the classical messages exchanged. In principle, an eavesdropper can break the encryption if they have access to a fast enough computer, either now (unlikely) or in the future (harder to guarantee)~\footnote{This is sometimes called "harvest now, decrypt later".}.  Therefore, RSA and Diffie-Hellman are not unconditionally secure~\footnote{Cryptographers are working to replace these mechanisms, in a broad push called \emph{post-quantum cryptography}, or PQC.  As of this writing, the first major phase of this process is nearing completion.}.

A crucial point is that quantum computers can in principle break some computationally secure protocols, notably RSA and Diffie-Hellman, with relative ease~\footnote{The details of this possibility are a very long discussion.}. So, how can we actually establish a secure connection between Alice and Bob? An alternative is to use some generator, some hypothetical device, that can generate a secret key, and that key is then shared with Alice and Bob in some secure fashion. Now, Alice and Bob are sharing some correlated secret key that only they know, and they can use it to encrypt their messages. For example, Bob encrypts a message, then sends it to Alice, who uses her knowledge of the secret key to decrypt it and read the message.

The bulk encryption mechanism can be AES, introduced in the last section, but the details are beyond the scope of this book. Or, we can encrypt one bit of message using one bit of key material.  One way to do this using an XOR operation.  If $m_i$ is the $i$th bit of the message, $k_i$ is the $i$th bit of the key, and $c_i$ is the $i$th bit of the ciphertext, or encrypted message, then $c_i = m_i \oplus k_i$.  This approach is known as \emph{one time pad}\index{one-time pad} or the \emph{Vernam cipher}\index{Vernam cipher}, and it is provably secure. It cannot be broken, provided that the key material is used only once. So, if Alice has a message of $n$ bits that she's trying to send to Bob, she requires a secret key that's at least $n$ bits long, and once she uses that private key to encrypt her message she cannot use it again. If she has some other thing to say to Bob, they require a completely new and fresh secret key to ensure security. So, it's not very efficient in the sense that it requires large amount of key bits, at least as many as the message itself.

That's actually pretty good, but there is one remaining question if we want to use the one-time pad, and that's how we actually distribute this key.  Perhaps our hypothetical key generator is used only during Alice and Bob's face-to-face meeting.  But, we already know that that is impractical.  Our only alternative is to use the public channel available.  The classical public channel is subject to being recorded, as noted above, but a quantum channel offers unique properties that allow us to guarantee that no one is listening in.  We will see how this can be achieved in the next section.

\section{BB84 Protocol}

This protocol is a quantum protocol, therefore Alice and Bob can utilize a public quantum channel, as well as their public classical channel.

So here (on slide) we've got Alice and Bob again, and they can communicate over this public quantum channel. What Alice does to begin the protocol, is she generates two n-bit strings. We're going to call the first n-bit string "a", so there's n bits in her string a, we're going to denote them a1, a2, up to a-n, and the second bit string we're going to denote is "b", and there's b1, b2, all the way up to b-n.

And then what she does is she creates quantum states according to these bit strings as follows:

For each two bits from a and b, she takes them and creates one qubit, and then she creates n such qubits and the whole state will be denoted by psi. So, if her qubits a-k and b-k are (in state) (zero zero), then she encodes this qubit, she prepares the qubit in the state zero. If a-k and b-k are (one zero), then she prepares state one. Similarly, if they are (zero one), she prepares state plus, and if they are (one one), she prepares the state minus. So, we can see that the bit coming from the bit string b, determines the basis of Alice's encoding. If it's zero, as we can see in both of these cases here and here (see pointer), she prepares the qubit in the z basis. If it's one, as we see in this case and in this case (psi 01, 11), then she prepares the qubits in the x basis. And a-k then chooses which state from the basis she prepares. If a is zero, she prepares the plus one eigenstate, if it's one, she prepares the minus one eigenstate.

Notice that these states are not orthogonal. For example, if we take the inner product between psi zero zero and psi zero one, like here, we see that they are not orthogonal, meaning that their inner product is non-zero. In this particular case, it's one over square root of two. Same if we take, for example, the state psi one zero and psi one one, again we will get that the inner product is non-zero. When this happens, when the inner product is non-zero, it means that the two states are not perfectly distinguishable, and this is crucial ingredient in this protocol. So what does it mean for two states to be non distinguishable? Let's consider the case where we are measuring in the z basis, and we are given two states. One state is the "zero state", and the other state is the "one state". If this happens, we see that they are orthogonal, it means we can perfectly distinguish them. So if we just keep measuring the incoming qubits, if the qubit is in zero, we will always get a plus one outcome. On the other hand, if the qubit is in one, we will always get minus one outcome. So with certainty, we can distinguish whether the incoming qubit is a zero or a one.

Same thing applies if we are measuring in the x basis, and we are given only state plus or state minus, like here (follow pointer). If we keep measuring x and we get this state, then the outcome will be always plus one with hundred percent probability. If on the other hand we get a minus state, and we measured in the x (basis), we will get outcome minus one all the time. So in this sense, we can distinguish plus and minus if we're measuring in the x basis.

On the other hand, let's say that we are given this following states- zero or a plus, and we measure in the z basis. So if we measure the zero state like we said we always get the plus one outcome, that's fine. But if we measure the second state, the plus state, there's a fifty percent probability that we get the outcome plus one and fifty percent probability that we get the outcome minus one.

So, if we get a state zero, all is good, but if we get the state plus, sometimes we will get a plus one and sometimes we will get a minus one. If we get the minus one state, fine, we can say we know that this state is plus, but if we get the plus one outcome, we are unsure whether the state is a plus or whether it's a zero. In this sense, the states are non-distinguishable. We can do the same thing in the x basis, and here the scenario is reversed. With certainty, we can say that we get plus one outcome here (yellow box RHS), but if we measure in the x basis and we receive the state zero, sometimes it will be a plus one and sometimes a minus one.

So let's consider an example of the encoding. Let's say that Alice generates "string a", which is (zero one one zero one), and "string b" (one one zero zero one). So then, she starts encoding, she looks at the first bit in her string b, which is one, so she knows, "now I have to encode in the x basis", and the state that she prepares is a plus state because her first bit in the a-string is a zero. So, that's her first qubit that she prepares. The second qubit, she looks at the second bit in her string-b, which is again one, so again she knows she has to prepare a state from the x basis, and the state is given by this second bit in string-a, which is one, therefore she prepares the state minus, and then she goes on and on until she prepares all n-qubits.

What she does then is she sends these qubits to Bob over the public quantum channel. Now, let's consider what Bob knows at this time. He actually doesn't know what these states are, because Alice did not share the secret string-b containing information about the preparation basis with anybody, she kept it secret. Therefore, all Bob knows is that he's receiving qubits and they can be any of the four possible states: zero, one, plus, minus. But, what he does, he goes on anyway and he creates his own random bit string which we are going to denote as b-prime. And again, because he's expecting n-qubits, he generates n-bits: b1 prime, b2 prime, all the way until b-n prime. And what he then does, he just measures in the basis given by this bit string.

So, similarly to Alice, if the bit "b-prime k" is zero, then he measures in the z basis, and if it's in one then he measures in the x basis. This allows him to generate his own random bit string which we will denote "a-prime". So if the outcome of the k-th measurement on the qubits is plus one, then he will assign zero to bit "a-prime k", if it's minus one, then he assigns a bit one to "a-prime k", and this way he generates his own "a-prime" random bit string. What then happens is that Alice and Bob, they share information with each other over a public classical channel. Alice shares her randomly generated bit string n, and Bob shares his randomly generated bit string b-prime.

So, they exchange information about the basis in which the qubits were prepared and in which they were measured.

And what they do is, if they measured and prepared in the same basis, they will keep the corresponding bits from "a" and "a-prime". If they measured in different bases, then they just discard the bits "a-k" and "a-prime k". Why? Because as we said, if Alice prepares in a certain basis and Bob measures in that basis, the two possible states are orthogonal, meaning they are perfectly distinguishable by measurement in that basis, so it allows Bob and Alice to generate a perfectly correlated key. So the bits that they keep, we're going to denote as "a-bar" and "a-bar prime", and they are perfectly correlated, meaning that these two shorter bit strings that they generated are in fact, equal. And now, they are sharing a key that they can use in the next step, which is encryption of the data.

So for example, how does it work? Let's again consider case where n is equal to five. So Alice has randomly generated five bit strings, a and b. "b" tells her in which basis she should encode, "a" tells her what the state should be. So she prepares the following states: (minus zero plus minus one). Bob generates his own random b-string, "b-prime". Again, this bit string is different from Alice's "b" because he doesn't know Alice's "b" at this time, and he just measured in the basis given by b-prime, so here the first bit in b-prime is one. Therefore, he measures in x on the second bit. It's again one, therefore he measures in x, and so on and so forth. And you can see that since for the first qubit, Alice encoded the qubit in basis x, and Bob measured in basis x, therefore Bob will always, with hundred percent probability, get the outcome minus one, which we said corresponds to bit string a-prime which is equal to one. And we see that in this case, "a-prime one" is the same as Alice's "a one". On the other hand, for the second qubit, Alice prepared the qubit in the z basis. But because Bob's random bit "b-prime two" is given by one, he measured in the x basis. So with fifty percent probability he can obtain zero, with fifty percent probability he can obtain one. So they cannot be sure that they are really sharing a correlated bit, therefore they discard this bit (second bit/row). For the third qubit, again Alice prepared in the same basis as Bob measured, therefore they know in this place, they can keep this bit and use it as part of their secret key. And this way, they can generate shorter keys but which are one hundred percent correlated. So here (see slide), we see for the first bit, they keep it, second one they discard, third one they keep it, fourth one they discard, and the last one they also keep.

So, the shared key that they have is given by: (one zero one).

So, here's the summary of the protocol so far: Alice starts by generating two n-bit strings, a and b. "b" is used for basis of the preparation, whereas "a" tells which state of that particular basis Alice should prepare the qubit in. If b-k is equal to zero, then she prepares in the z basis, if b-k is equal to one, she prepares in the x basis. Then, Alice sends these qubits to Bob over a public quantum channel. Bob measures randomly either in z or x basis. After the measurements are completed, and only after that, they are allowed to share the information about the preparation basis and the measurement basis, and they keep the bits only where they prepared and measured in the same basis. Again, they do that because they are guaranteed that in this scenario, the results that are generated are hundred percent correlated. And whatever is left of the key, they use as a secret key for encoding and decoding their messages.

Now, so far, we have only considered the ideal scenario where there was no eavesdropper. Now let's say that somebody is listening to both the public classical channel, but also the public quantum channel. So we are going to consider the effect of an eavesdropper whom we are going to name Eve, and see what effect that has on the protocol and how the protocol can actually discover the presence of such an eavesdropper.



\section{Eavesdropper detection}

In the previous section, we saw how the ideal protocol works. Now let's see what happens when we include the effect of an eavesdropper trying to gain access to the secret key that Alice and Bob are trying to generate.

So we've got the following scenario: we've got our Alice communicating over a public quantum channel with Bob, and there is some third party Eve, that wants to intercept their messages.

So, what can Eve do? Let's assume that she can take these qubits (follow pointer) that Alice is sending over the public quantum channel to Bob. She intercepts them, she can copy them and then resend them to Bob. That would give her access to the protocol and the qubits, and also subsequently the secret quantum key. Luckily, she cannot do that due to the "no cloning theorem" as we have seen in the previous lesson, in the teleportation lesson. So, she cannot simply take them, make a copy of the qubit, and then resend the qubits to Bob. That's good. So in order for Eve to gain any access to the information that Alice is trying to share with Bob, she has to measure these qubits. So, what can happen then? She has to guess the basis of measurement, because remember, the preparation basis stored in the bit string "b", is still kept a secret by Alice, that has not been communicated over a public classical channel to Bob. Therefore, Eve does not have access to this information. So, in order to measure these qubits, she just has to pick a random basis. But, she knows that the two choices for the basis is either z or x.

So, if she measures in some basis, this has a chance to disturb the qubit.

For example, if Alice prepares the qubit in the x basis, and Eve measures in the x basis, then we have seen that in such a scenario, there is no disturbance. The qubit is still projected onto the same state that it was prepared in, so it doesn't change the state of the qubit and it doesn't change the basis of the qubit. However, in the second case, let's say that Alice's preparation basis is "z", and Eve's measurement basis in is x, so the qubit originally prepared by Alice was either in a zero state or a one state. These are just two possible states in the z basis. But by measuring them in the x basis, Alice is now projecting onto the either plus state or a minus state. So, she disturbed both bases and the state. Similarly in this scenario here (follow pointer), where Alice prepares in the x basis and Eve measures in the z-basis. And this is the main principle how Eve will be detected by Alice and Bob.

So, if she guesses wrong, if Eve guesses wrong, she will change the basis of the qubit.

So let's see what happens. Alice prepares her qubits, she starts sending them over the public quantum channel, Eve intercepts these qubits and she measures them in a random basis, and then she passes on these qubits to Bob. So, some of these qubits where she guesses correctly, so she measures in the preparation basis, they do not get disturbed. But some of these qubits, represented by these black qubits (see slide), they become disturbed. This is when Alice measures in a different basis than the preparation basis. Then, this gives Alice and Bob an opportunity to detect that there is an eavesdropper present. How does that happen?

Basically, what they need to do is they go through with their BB84 protocol. They compare their bases in which Alice prepared and both measured. They keep only those bits where they measure the qubits in the same basis, and then they dedicate a portion of this new shorter key to finding to detecting an eavesdropper Eve. So Eve has a chance of measuring in the same basis as the preparation basis of one half, so fifty percent. And also Bob chooses the same basis as Alice with probability fifty percent. So this gives Alice and Bob a probability of one quarter to detect an existence of Eve, because remember, if Alice prepared in one basis and Bob measured in the same basis, they are expecting this classical measurement outcomes to be the same- they are expecting to share a perfectly correlated key. But if Eve measured this qubit and disturbed this qubit, then there is a chance that these two bits will not coincide, and if they don't coincide then Bob and Alice know that something went wrong and there's an eavesdropper present trying to gain access to their secret key.

So, we said that "Eve" (the eavesdropper) can be detected with probability one quarter when it comes to measuring a single qubit. When there's n qubits that she measures, the overall probability of detecting "Eve" is given by the following expression: one minus three quarter to the power of n. So let's see how this scales with the number of n.

Here it is (see slide): on the horizontal axis, we're plotting the length of the bit string that we dedicated to detecting an eavesdropper Eve, and on the vertical axis, we've got the probability of detecting Eve. So you see, as the number is very small, so "small n" is very small, we don't dedicate too many bits to actually trying to detect the eavesdropper, then also the probability that Eve is detected is relatively small. But very quickly, this probability shoots very close to one. So with nearly a probability of hundred percent, Alice and "Bob" can detect the presence of an eavesdropper. Even for n equals to 25 (twenty five), so if they dedicate 25 bits to detect Eve, the chance is one in a thousand that Eve will not be detected. So it's very very small, meaning with very high probability, Alice and Bob know that somebody's eavesdropping onto their channel, so they can just say, "we know that we are not sharing a secure secret key, therefore we choose not to continue with the rest of our communication, and we don't allow Eve to gain access to our sensitive message".

\section{Existing QKD network testbeds}

In the previous sections, we have seen how Alice and Bob can use quantum mechanics to discover an eavesdropper and generate a secret random key for secret communication. In this step, we will demonstrate that actually these things are not only in the realm of theoretical research, but also have been tested by building real networks.

The very first network that was built was known as the DARPA QKD network, all the way back in 2004. This included ten nodes in a network, and it was built in the state of Massachusetts in the USA. It included different physical links, for example, you had a communication over free space, here you had a communication over a fiber. So this was unlike any of the previous experimental implementations where secure quantum communication in the form of a single photon-based QKD was done only on a point-to-point basis over a single link. This was the first network experiment demonstrating the viability of quantum key distribution.

The next experimental effort was in Europe known as the SECOQC QKD network. SECOQC stands for "Secure Communication based on Quantum Cryptography", and it was around the year 2008. It launched in Vienna, and it comprised of six nodes and eight links, and involved the layered architecture. And finally, there are many other experiments but one notable one was done in Tokyo around 2010, and it was known as the Tokyo QKD network. Here (follow pointer), you can see the physical map actually, which places in Tokyo were connected. You have Hongo campus here in Tokyo University, you've got Otemachi over there, and it reached all the way to NICT in Kogane, and the interesting part about this network that actually it was used for a quantum secure video conference which really demonstrated the viability of using quantum mechanics for securing communication in a network.


\newpage
\begin{exercises}
\exer{Consider the following quantum state:}
\begin{equation*}
\ket{\psi} = \frac{\sqrt{3}}{2}\ket{0} + \frac{1}{2}\ket{1}
\end{equation*}
\subexer{Find the probability of measuring a zero.}
\subexer{Find the probability of measuring a one.}


\end{exercises}

