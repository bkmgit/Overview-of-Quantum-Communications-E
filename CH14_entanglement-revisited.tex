\chapter{Entanglement Revisited}

In this chapter, we will return to entanglement and discuss it in more detail and in the context of quantum repeater networks.
We begin with revisiting bipartite entanglement in section~\ref{sec:14-1_bipartite}.
We focus on how to determine the quality of the entanglement shared between distant of nodes of a network and why it is important.
In section~\ref{sec:14-2_multipartite}, we will introduce multipartite entanglement shared between more than two nodes of a quantum network.
We will introduce what it is and how it differs from bipartite entanglement before moving on to examples of multipartite entangled states.
In the remained of this chapter, we will shift our focus to applications of quantum repeater networks.
In section \ref{sec:14-3_clock_sync}, we discuss clock synchronization, and distributed blind quantum computation in section ~\ref{sec:14-4_distributed_bqc}.



\section{Bipartite entanglement}
\label{sec:14-1_bipartite}

One of the main jobs of a quantum network is to distribute entanglement.
So let's start by considering a concrete example, where we have the following networks where these circles represent quantum nodes and these dashed lines represent physical links between certain nodes of the network. And let's say that these green nodes are trying to engage in a quantum communication, so they would like to establish an entangled pair between themselves, so we're going to label them N1 and N2. And we saw in previous chapters that how this works in a quantum network is that first, we have to establish link-level entanglement- so entanglement between neighboring networks that are connected directly by via physical link, and then we can use entanglement swapping and the intermediate nodes in order to end up with an entangled connection between N1 and N2. And we also talked about that the network has to consider things like routing and multiplexing in order to satisfy the need for quantum communication between multiple users of the quantum network. So- but one question which we have not addressed in detail is how do we evaluate the quality of the established entanglement? After all, we saw that the quality directly impacts some of the protocols.

So, we saw that in entanglement-based QKD, the quality of the entanglement that's shared between Alice and Bob directly impacts the key that they're trying to establish. Namely, if the entanglement is not perfect, if they don't share a pure maximally entangled state, then the key that they are going to end up with after at the end of the protocol will also be only partially correlated. More crucially, the quality of the entanglement also tells us something about the security of the entire protocol. If they are not sharing a maximally entangled state, there is some chance that their qubit is correlated with some qubit that Alice has in her possession, which means that clever Alice can find some information about the secret key that Alice and Bob are trying to establish. So in this scenario, we see that better quality of entangled states lead to stronger security during the establishment of a secret key. So what are the different methods of evaluating the quality of the distributed entanglement when we talk about bipartite entanglement? We saw that fidelity is one function that we can use to talk about the quality of a state at the output, either of a quantum communication task or a quantum computation task. Here, we have some reference state which is a pure state that describes our ideal state that we are aiming to get- that's our desired state. But due to noise, usually what we have is is some mixed state, and if the noise doesn't have much effect, if it's very weak noise, this state will be close in some sense to the ideal state- our reference states "psi".

And we can evaluate how close we are using the fidelity, which I remind you is computed in the following way- we have the fidelity "f" between the actual state "rho" and our ideal state psi, given simply as this inner product.

In the context of quantum networks, generally we are trying to establish bipartite entanglement between end-to-end nodes, so we are mainly interested in the following expression, and that's the fidelity of the state that two nodes are sharing, and the ideal state that they wish to share, which is a maximally entangled state, in this case we will consider the phi plus state.

And let's compute some examples. So let's say that we have the ideal case, meaning there is no noise, there's no eavesdroppers, and the actual state that the two parties are sharing is really the pure state phi plus, here written as a density matrix. Well, we can just simply substitute that into our expression for the fidelity and we see that what we get is the square of the inner product between phi plus and phi plus, which of course we have seen many times is one because the state is normalized. So, good- we get fidelity of one, meaning we have the ideal state. Now, what if we end up with an orthogonal state? So maybe something has gone wrong, due to some noise Pauli Z matrix was applied to our ideal state, and the two parties end up with the following state. It's still a pure state but it's not the desired status. In this case, it's phi minus. If we substitute that into our expression for the fidelity, we will see that fidelity drops to zero and that's because our state that the two parties are sharing is orthogonal with the desired state phi plus. But here's the problem- we care that the two states- that the two parties Alice and Bob, are entangled, and here they are clearly entangled. They manage to share entanglement. It's not their desired entanglement, it's not the desired Bell state phi plus, but it's still an entangled state nonetheless. But if we just simply evaluate the fidelity, we get a zero. Meaning that our state is no good and that's not quite what we're looking for. So we see that fidelity in this scenario is not a very good measure. So, what can we do?

Well, we saw previously in the entanglement-based QKD protocol that we can test quantum correlations by violating the CHSH inequality. To remind you, we have considered the CHSH inequality, and the state psi plus which we used in the E91 protocol. And there, Alice measured in two different bases given by these vertical and horizontal lines in the exact plane of the block sphere, so A1 corresponds to measurement of the Pauli Z observable, A2 corresponds to the measurement of the Pauli X observable, and Bob measures in this rotated basis, B1 and B2, given by this following expression. So B1 is given by Z minus X, whereas B2 is given by Z plus X.

And Alice and Bob, they have to repeat this process many times, perform these measurements, build up statistics, so that they can compute their expectation values for the following measurement settings, where Alice measures in A1 and bob measures in B1, Alice measures in A1 but Bob measures in B2, and so on. And together, we can form this following expression known as the CHSH expression. And if this is larger than two, then we can conclude that the state that Alice and Bob are sharing is really, in fact, entangled. So, okay, that seems to work. Let's try and use the CHSH inequality for our state phi plus that we are trying to verify.

Well, we can again consider the same measurements and we construct the same CHSH expression. If you go through the calculation for the expectation values, you can quickly find out that the expectation value for A1B1 is equal to A1B2, and also A2B2, and it's given by one over square root of two. And the expectation value for A2B1 is negative one over square root of two. So we can substitute all these values back into our expression for the CHSH expression. So here we have one over square root of two plus one over square root of two, and we have here we have minus one over square root of two because we are substituting this expression, and then minus one over square root of two. So we get that S is equal to zero, and we said that in order to certify that the state is truly entangled, it has to be larger than two. But phi plus is clearly entangled. So what went wrong? Well, the answer is actually very simple, and it's the fact that this inequality has been constructed specifically for the state psi plus, but now we are trying to use it on the state phi plus. So in order to use CHSH inequality as a test for entanglement, we need to fix our current expression for S. Luckily, in this case it's very simple. All we have to do is just swap these signs- this negative sign with plus sign over here. And with this new expression, we can actually find out that truly, S is equal to two root two, which is the maximum violation of CHSH inequality, which always has to be true if they are sharing maximally entangled state. So we saw here that CHSH inequality can detect bipartite entanglement, and to remind you, if we go through the CHSH test and we obtain the value S larger than two, then we have an entangled state "rho". If S is equal to two root two, then we can say that the state that Alice and Bob are sharing is maximally entangled. And if the value of S is less or equal to two, then the test is inconclusive. Now, notice that I have not said that the test does means that the state is separable, and that's because there are some entangled states which do not violate this inequality. However, if we find violation, then we can automatically conclude that the state is entangled. And also, we have to be mindful of what CHSH expression we are using, make sure that it's the correct one, make sure that you're using the right combination of those four expectation values with the correct plus or minus signs, depending on which state you are trying to test- "is it phi plus, phi minus, psi plus or psi minus?".



\section{Multipartite entanglement}
\label{sec:14-2_multipartite}

Step Two: Multipartite Entanglement

In the previous step, we have seen how we can establish a bipartite entanglement- that means entanglement only between two nodes and between two qubits. But of course, we can consider also other types of entanglement, namely entangling between more than two nodes. For example, in a network we may wish to entangle three nodes like this, then we refer to this case as "tripartite entanglement", or it could be entanglement share between four nodes so a four-partite entanglement, and we can go up and up until we have entanglement between "n" number of nodes, or we have multipartite entanglement. So let's consider just three qubits as starters. How many basis states are there? We saw that for the case of two qubits, there are four basis states- zero zero, zero one, one zero, one one. Well, you can guess that for the case of three qubits, there are eight basis states and they're given by all these possibilities- we have the three qubits being zero zero zero, zero zero one, and so on and so forth all the way to one one one. And any general pure state can be written as a general superposition of all of these eight basis states. For example, we can write any general three-qubit state as follows here as a superposition of all of these with some arbitrary probability amplitudes given by c1, c2, all the way up to c8. Now depending on the particularities of the superposition that we take, we may end up in a separable state or an entangled state. So let's consider some examples of entangled states. Let's look at all of our possible eight basis states and take a very simple superposition of just the term zero zero zero and one one one. And to keep things simple we will consider this superposition to be an equal superposition, so we have an equal chance to be found in zero zero zero and one one one. Now this state is known as GHZ state, and plays a very important role in quantum communication as we will see shortly.

Let's consider a measurement on one of the qubits of the three-qubit GHZ state, and let's say that we measure it in the Z basis, and for concreteness let's just measure qubit one. So here's our three-qubit GHZ state. It's an equal superposition of (zero zero zero) (one one one) with probability of a half, we can get the plus one outcome. That means we project the state of qubit one onto a zero, and if that happens we can see that we end up with the state of the three qubits collapsing onto the following state. All of them can be found in zero zero zero. So we can see that the qubits are correlated. The other possibility is that we measure the outcome minus one. This happens with equal probability of a half and then you can see from this expression that the state of all three qubits collapses onto one one one. So again they are correlated, and we saw similar behavior when we were talking about establishing a secret key in entanglement-based QKD. What we were looking for was a scenario where performing measurements in the same basis can establish a secret key between two parties. Here you can see that you can do that- do the same thing between three parties, which is why GHZ states are used in quantum communication. In fact, you can see that by doing that just like in the case for the entanglement-based QKD, measurements consume the entanglement that was shared between the three parties. So by measuring just one qubit in the state means the total entanglement is destroyed. And in fact, it doesn't matter which qubit we measure in the Z basis. We would have ended up with the same case with the same probabilities if we had measured in the qubit two or qubit three.

Now let's move on to a different example known as a "W state". Again, here are our eight possible basis states, and this time we'll choose a different superposition. We will consider these three states, and we will take an equal superposition of these states. Now the normalization factor is one over square root of three, because we have three states- three basis states in the superposition rather than two that we had in the previous example of the GHZ state, and as I said, this is known as the W state. So how do measurements affect the W state? Again, let's measure in the Z basis and perform this measurement on qubit one. What can happen is that with probability two-thirds we get the outcome of plus one, because we have these two contributions from these two terms in the superposition, therefore the probability is equal to two-thirds. When that happens, our first qubit is projected onto the state zero, but our remaining two qubits, qubits two and three, remain in an entangled state, and this time they share the maximally entangled bell pair denoted by phi plus. And the other outcome is the minus outcome of the Z measurement on qubit one which can happen with probability one third, and if that happens then we just end up in a separable state (one zero zero). So we see that unlike in the case of a GHZ state, here we don't necessarily always destroy the entanglement that was initially present in the system. And in this sense, we can say that W state and GHZ state are not equivalent. Now, we have been talking about the various correlations that three parties can share. We said that GHZ state, if we measure in the Z basis one of the qubits, all of the entanglement is destroyed. Whereas if we take the W state and we measure, we don't necessarily destroy all of the entanglement. So somehow, this tells you that the correlations that are shared in these two states are not quite the same. But there must be some constraints on how correlated the various parties of the state can be, how correlated one and two are with three, and so on.

So here we have our three qubits- qubits one, two, and three, and they are in some correlated state, maybe in some entangled state. How strongly can various qubits be correlated? Well, there is a constraint known as monogamy of entanglement, which we have seen in a previous chapter on the E91 protocol- the entanglement with QKD protocol, and we see that there is a trade-off. If two pairs of the qubits are strongly correlated, then their correlation with the third party is limited. In particular, if qubits one and two are in a maximally entangled state, then we know that the total state must be of this form. We have the maximally entangled state of qubits one and two, tensor product with some arbitrary single qubit state. So we say that qubit three is completely uncorrelated with the remainder of the state of winning qubits one and two. Similarly, if we have maximal entanglement between one and three, then qubit two must be completely uncorrelated with the pair one and three.

This principle of monogamy is one of the most fundamental properties of quantum mechanics. It's unlike anything that exists in classical physics, and is one of the cornerstones and building blocks which we use in quantum technologies, and particularly in quantum communication. So, we have seen examples of three qubit states. Can we extend the GHZ state and W state to many qubits, let's say "n" qubits? And of course, we can do that quite easily. The GHZ state for n parties or n qubits has the following form. Again, here we pick only two terms- one corresponding to n zero zero zero zero... and the other one we have n one so- one one one one one one one... and we take the equal superposition of them. Notice that the normalization factor here has not changed, even though we have n qubits. That's because we only have two terms in the superposition. On the other hand, the W state for n parties, we have the following superposition of n terms. Therefore, the normalization factor must change to one over square root of n, and what it is, is really we have n minus one zeros and then one one... and we place this one at all the possible places, and we take the superposition of all the possible cases where we have n minus one zeros and a single one. So we have n qubits and n terms.

But this is not the only example of a useful entangled state of many qubits. There are many other examples, but two are extremely important both in quantum computation and quantum communication. Let's say that we have a network of qubits and we prepare every qubit in the state plus. So this is an equal superposition of one and zero. And then we apply an entangling gate known as a "control-Z gate". In the matrix form, it looks something like this. So it's very similar to a CNOT gate- a control-NOT gate, but this time instead of applying the Pauli X in a controlled way, we are applying the Pauli Z in the controlled way. So if the control qubit is in the state zero, we don't do anything. If it's in the state one, we apply the Pauli Z matrix. And this gate is entangling- and entangles all of the qubits together into a multipartite entangled state. And this is the preparation procedure for a state called a "graph state", normally denoted by "ket G". Now if the state has a regular lattice structure, we can still refer to it as a graph state, but commonly it is referred to as a cluster state and denoted by "ket C". And by regular structure I mean the following topology like this.

Now graph states and cluster states are very important in quantum computation. They form the resource states for a particular computational model known as "measurement based quantum computation", but they are also very useful in content communication where multiple parties are trying to communicate, and they are crucial in quantum error correction as well which you will see in a different module.


\section{Clock synchronization}
\label{sec:14-3_clock_sync}

So we have seen in this module, the applications of how we can use entanglement. We saw the example of teleportation, and we saw the example of entanglement-based QKD. Here in the remaining two steps of this chapter, we will consider a few other examples of applying entanglement. And here in step three, we will look at clock synchronization. So before we say how we can synchronize clocks, let's ask the question- why we want to synchronize clocks. Well, establishing universal time standard is fundamentally important in many areas of modern life. The telecommunications networks require synchronized clocks, global positioning system (GPS), financial markets, transportation networks, these are all just a few examples of crucial importance to modern way of living. For example, if we look at the GPS, how it works, how it calculates the very accurate position of where we are, is it computes the distances to four satellites and then from that it can locate with very high degree of accuracy where we are placed on Earth. And in order to calculate this distance- is this R1, R2, R3, and R4, accurate timing is very important because even tiny errors in timing can result in huge positional errors. So how can we synchronize clocks? Well, there are really two classical methods and one quantum method which we will mention. The first one is due to Einstein. Imagine that we have two clocks- one is in possession of Alice and the other one is in possession of Bob, and they are trying to synchronize- Alice is trying to synchronize her clock with Bob's clock. So what she can do, is she can fire a pulse of light towards Bob. So the light is traveling to Bob and it reaches Bob. As soon as it reaches his clock, it bounces back and as it's doing that it sets Bob's clock ticking. Alice is measuring the time that it takes for the photon- for the light pulse to travel from her to Bob and bounce back. From that, she knows she can estimate the distance to Bob, she calculate the distance to Bob, and also she will know what's the round-trip time, and also what's the time in order for the photon to reach from Bob to Alice. Therefore, she knows how she can set her clock, and this will synchronize the two clocks together. However, in this scheme, Alice needs to know where Bob is located in order to correctly synchronize their clocks. A different scheme is for Alice to have some other smaller clock which she synchronizes locally with her clock, and then the small clock is very slowly, in fact adiabatically slowly, transferred to Bob where he receives the clock and then he can locally synchronize his clock with this received clock. And this scheme has to be done adiabatically slowly because of theory of relativity. Now the third scheme is realizing that qubits can act as tiny clocks. How does that work? Well qubits, they evolve in time. For example, if we prepare a qubit in an equal superposition of zero and one, we can make it change its state in time such that it goes around this x-y plane in the Bloch sphere with angular frequency "capital omega". So, it starts, we can initialize it in the state plus, and after some time capital T which is the period of precession, it completes one full circle. So it goes around an angle of two pi radians. So the period of precession is given by two pi divided by the angular frequency of precession. So, really in this sense, it's the same as a grandfather clock. If we can track how many times it goes around the x-y plane, we can track time knowing the angular frequency of precession. So the question now is- how can we synchronize two qubits? Let's say Alice has qubit one that is processing at a frequency capital omega, and Bob also has one that's also processing at the same frequency but this time there is some offset so it's lagging behind Alice's qubit clock. So this "delta" is quantifying the lag between- in terms of the angle between the point that's on the Bloch sphere in the x-y plane for Bob and for Alice, and what we are trying to do is we are trying to eliminate this offset delta in order for their clocks to be synchronized and show exactly the same time. So where is the main problem? Well, the problem is that Alice has her local time frame and Bob has his own local time frame, and somehow they need to communicate, like, say "my time frame is this, what is your time frame?", and they have to exchange messages in order to agree on a global time frame.

In fact, what they can do is they can do that by sharing entangled pairs of qubits. They can use these qubits to establish a global time frame.

So in that sense, entanglement is used as a global resource, and we have seen the similar scenario also in the entanglement-based QKD. There, we use entanglement and classical communication to correlate to- in order to establish a correlated secret key between Alice and Bob. That was the E91 protocol. In clock synchronization of qubits, we are using the global correlations that are present in a maximally entangled state in order to establish a global time frame and correlate these two qubit clocks together, therefore synchronizing them.

And quantum networks are instrumental in distributing bipartite entanglement, therefore allowing the various nodes in the network to synchronize their clocks and establish a global time frame.



\section{Distributed and blind quantum computation}
\label{sec:14-4_distributed_bqc}

Step Four: Distributed and Blind Quantum Computation

This will be our final example of the application of entanglement and quantum network in this chapter.

So let's talk about distributed quantum computation first. There is no reason for Alice to perform all of her quantum computation locally. Let's say that her resources are limited. Maybe she doesn't have the large number of qubits, or the qubits that she has are not of sufficient quality. But that doesn't mean that she cannot perform her quantum computation. What she can do is she can contact her friends, Bob, Charlie, Dave and Eve, who are also in possession of some limited computational resources. They also have some small quantum computers. And together, they can coordinate their resources and perform a larger quantum computation compared to if Alice did it only locally.

So here, Alice, Bob, Charlie, Dave and Eve, they all share some number- small number of qubits, and they can entangle in some them in some way, and also they can exchange quantum information by using the quantum network, or they can also exchange some entangled qubits, they can connect those local cluster states together in some larger cluster states and then perform computation on that. And there are many questions of interest, such as what is the most efficient way of networking the quantum processors together, how many messages do they need to exchange in order to coordinate their computational efforts, and also issues like trust- how can Alice trust. Maybe she doesn't trust all of the parties involved in the quantum computation. What does she need to do? How can quantum network help her in this situation?

Also, here we are assuming that she has some quantum resources. What if her quantum resources are extremely limited? So what do we mean by "extremely limited"? Let's say that she cannot do anything. She doesn't have a quantum computer but she would still like to delegate her quantum computation, and for simplicity let's just assume that Bob has a full-fledged, very powerful, large quantum computer where he can perform any quantum computation that he wishes or that Alice would ask him to do. So in this scenario, what she can just do is she can send him a classical message composed of many bits, describing to Bob exactly what computation she wishes him to perform. So, she needs to describe the input of the computation, the computation itself, and then Bob will just take this information and carry out the computation, and then tell Alice the output- the result of the computation. But in the process, what happens is he learns everything there is to know about the computation. He learns the input, he learns the computation itself, and he learns the output. Now, what if Alice doesn't want Bob to learn some of this information, or any of this information? Maybe she's trying to gain a competitive edge by performing some simulation of a molecule or a new material, and she doesn't want Bob to find it out because it's a trade secret. Can she still do something in this case? Well, she can if she's allowed to have some quantum resources. And particularly, we assume that Alice has the ability to generate single qubit states. So, what she can do is she generates these states and then she can randomly rotate them. Then she takes these keywords and she sends those to Bob, so she's using a quantum channel to communicate with Bob. But these qubits are not entangled, they're really just a bunch of single qubit states randomly rotated.

And then she sends him classical instructions about the computation. So she directs Bob- "take qubit one, perform this operation, take qubit two, perform that operation, take these two qubits and entangle them using this gate", and so on.

And in this way, Bob can perform whatever she is instructing him to do and then just return the final outcome. He communicates either in quantum way or classically to Alice about the result of the computation, and in this way Bob does not know the random rotations because those are still kept secret by Alice. So this prevents him from learning anything about the input, anything about the computation itself, and also anything about the output. He's basically doing this computation blind. He's performing some operations according to Alice's instructions, but because he doesn't know the initial states of the keywords, he doesn't really know what these operations mean. He cannot interpret them, therefore whatever he gets, he just performs the operations blindly, he gets some output, but he cannot interpret this output, he just returns it to Alice. The only thing that he can learn is the upper limit to Alice's computation. For example, if she sends him four qubits then he knows that she, Alice, could not have performed any computation that requires more than four qubits.



\newpage
\begin{exercises}
\exer{Consider the following quantum state:}
\begin{equation*}
\ket{\psi} = \frac{\sqrt{3}}{2}\ket{0} + \frac{1}{2}\ket{1}
\end{equation*}
\subexer{Find the probability of measuring a zero.}
\subexer{Find the probability of measuring a one.}


\end{exercises}

